/* tab-bar.c generated by valac 0.28.0, the Vala compiler
 * generated from tab-bar.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <stdio.h>


#define TYPE_TAB_BAR (tab_bar_get_type ())
#define TAB_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TAB_BAR, TabBar))
#define TAB_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TAB_BAR, TabBarClass))
#define IS_TAB_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TAB_BAR))
#define IS_TAB_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TAB_BAR))
#define TAB_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TAB_BAR, TabBarClass))

typedef struct _TabBar TabBar;
typedef struct _TabBarClass TabBarClass;
typedef struct _TabBarPrivate TabBarPrivate;

#define TYPE_DOCUMENT_TAB (document_tab_get_type ())
#define DOCUMENT_TAB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DOCUMENT_TAB, DocumentTab))
#define DOCUMENT_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DOCUMENT_TAB, DocumentTabClass))
#define IS_DOCUMENT_TAB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DOCUMENT_TAB))
#define IS_DOCUMENT_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DOCUMENT_TAB))
#define DOCUMENT_TAB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DOCUMENT_TAB, DocumentTabClass))

typedef struct _DocumentTab DocumentTab;
typedef struct _DocumentTabClass DocumentTabClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

struct _TabBar {
	GtkBox parent_instance;
	TabBarPrivate * priv;
	gint tab_num;
};

struct _TabBarClass {
	GtkBoxClass parent_class;
};

struct _TabBarPrivate {
	gint tab_extra_num;
	GtkStack* stack;
	GtkBox* extra_box;
	GtkEventBox* extra_menu;
	GtkPopover* extra_popup;
	GList* _extra_tabs;
	GList* _tabs;
};


static gpointer tab_bar_parent_class = NULL;

GType tab_bar_get_type (void) G_GNUC_CONST;
GType document_tab_get_type (void) G_GNUC_CONST;
#define TAB_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_TAB_BAR, TabBarPrivate))
enum  {
	TAB_BAR_DUMMY_PROPERTY,
	TAB_BAR_EXTRA_TABS,
	TAB_BAR_TABS
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
TabBar* tab_bar_new (void);
TabBar* tab_bar_construct (GType object_type);
static void tab_bar_create_widgets (TabBar* self);
static gboolean __lambda4_ (TabBar* self, GdkEventButton* event);
static gboolean ___lambda4__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
void tab_bar_set_stack (TabBar* self, GtkStack* stack);
void tab_bar_add_page (TabBar* self, DocumentTab* tab, gboolean new_page);
void tab_bar_close_page (TabBar* self, DocumentTab* tab);
static void _tab_bar_close_page_document_tab_close_clicked (DocumentTab* _sender, DocumentTab* tab, gpointer self);
void tab_bar_switch_page (TabBar* self, DocumentTab* tab);
static void _tab_bar_switch_page_document_tab_tab_clicked (DocumentTab* _sender, DocumentTab* tab, gpointer self);
GtkScrolledWindow* document_tab_get_tab_widget (DocumentTab* self);
static void tab_bar_refresh_marked (TabBar* self);
void document_tab_mark_title (DocumentTab* self);
DocumentTab* tab_bar_get_current_page (TabBar* self, GtkWidget* current_doc);
void tab_bar_switch_page_next (TabBar* self, DocumentTab* current_tab);
void tab_bar_switch_page_prev (TabBar* self, DocumentTab* current_tab);
gint tab_bar_get_page_num (TabBar* self, DocumentTab* tab);
static void __lambda5_ (TabBar* self, DocumentTab* entry);
void document_tab_refresh_title (DocumentTab* self);
static void ___lambda5__gfunc (gconstpointer data, gpointer self);
static void __lambda6_ (TabBar* self, DocumentTab* entry);
static void ___lambda6__gfunc (gconstpointer data, gpointer self);
GList* tab_bar_get_extra_tabs (TabBar* self);
GList* tab_bar_get_tabs (TabBar* self);
static void g_cclosure_user_marshal_VOID__OBJECT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void tab_bar_finalize (GObject* obj);
static void _vala_tab_bar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


TabBar* tab_bar_construct (GType object_type) {
	TabBar * self = NULL;
	self = (TabBar*) g_object_new (object_type, NULL);
	gtk_orientable_set_orientation ((GtkOrientable*) self, GTK_ORIENTATION_HORIZONTAL);
	gtk_box_set_spacing ((GtkBox*) self, 0);
	tab_bar_create_widgets (self);
	return self;
}


TabBar* tab_bar_new (void) {
	return tab_bar_construct (TYPE_TAB_BAR);
}


static gboolean __lambda4_ (TabBar* self, GdkEventButton* event) {
	gboolean result = FALSE;
	GtkPopover* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->extra_popup;
	_tmp1_ = gtk_widget_get_visible ((GtkWidget*) _tmp0_);
	if (_tmp1_) {
		GtkPopover* _tmp2_ = NULL;
		_tmp2_ = self->priv->extra_popup;
		gtk_widget_hide ((GtkWidget*) _tmp2_);
	} else {
		GtkPopover* _tmp3_ = NULL;
		_tmp3_ = self->priv->extra_popup;
		gtk_widget_show_all ((GtkWidget*) _tmp3_);
	}
	result = TRUE;
	return result;
}


static gboolean ___lambda4__gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = __lambda4_ ((TabBar*) self, event);
	return result;
}


static void tab_bar_create_widgets (TabBar* self) {
	GtkBox* _tmp0_ = NULL;
	GtkImage* extra_menu_img = NULL;
	GtkImage* _tmp1_ = NULL;
	GtkEventBox* _tmp2_ = NULL;
	GtkEventBox* _tmp3_ = NULL;
	GtkEventBox* _tmp4_ = NULL;
	GtkEventBox* _tmp5_ = NULL;
	GtkEventBox* _tmp6_ = NULL;
	GtkPopover* _tmp7_ = NULL;
	GtkEventBox* _tmp8_ = NULL;
	GtkPopover* _tmp9_ = NULL;
	GtkPopover* _tmp10_ = NULL;
	GtkBox* _tmp11_ = NULL;
	GtkEventBox* _tmp12_ = NULL;
	g_return_if_fail (self != NULL);
	__g_list_free__g_object_unref0_0 (self->priv->_tabs);
	self->priv->_tabs = NULL;
	__g_list_free__g_object_unref0_0 (self->priv->_extra_tabs);
	self->priv->_extra_tabs = NULL;
	_tmp0_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->extra_box);
	self->priv->extra_box = _tmp0_;
	_tmp1_ = (GtkImage*) gtk_image_new_from_icon_name ("view-more-symbolic", GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp1_);
	extra_menu_img = _tmp1_;
	_tmp2_ = (GtkEventBox*) gtk_event_box_new ();
	g_object_ref_sink (_tmp2_);
	_g_object_unref0 (self->priv->extra_menu);
	self->priv->extra_menu = _tmp2_;
	_tmp3_ = self->priv->extra_menu;
	g_object_set ((GtkContainer*) _tmp3_, "child", (GtkWidget*) extra_menu_img, NULL);
	_tmp4_ = self->priv->extra_menu;
	gtk_event_box_set_above_child (_tmp4_, TRUE);
	_tmp5_ = self->priv->extra_menu;
	g_signal_connect_object ((GtkWidget*) _tmp5_, "button-press-event", (GCallback) ___lambda4__gtk_widget_button_press_event, self, 0);
	_tmp6_ = self->priv->extra_menu;
	_tmp7_ = (GtkPopover*) gtk_popover_new ((GtkWidget*) _tmp6_);
	g_object_ref_sink (_tmp7_);
	_g_object_unref0 (self->priv->extra_popup);
	self->priv->extra_popup = _tmp7_;
	_tmp8_ = self->priv->extra_menu;
	gtk_box_pack_end ((GtkBox*) self, (GtkWidget*) _tmp8_, FALSE, TRUE, (guint) 3);
	_tmp9_ = self->priv->extra_popup;
	g_object_set ((GtkWidget*) _tmp9_, "width-request", 320, NULL);
	_tmp10_ = self->priv->extra_popup;
	_tmp11_ = self->priv->extra_box;
	gtk_container_add ((GtkContainer*) _tmp10_, (GtkWidget*) _tmp11_);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp12_ = self->priv->extra_menu;
	gtk_widget_hide ((GtkWidget*) _tmp12_);
	_g_object_unref0 (extra_menu_img);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void tab_bar_set_stack (TabBar* self, GtkStack* stack) {
	GtkStack* _tmp0_ = NULL;
	GtkStack* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (stack != NULL);
	_tmp0_ = stack;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->stack);
	self->priv->stack = _tmp1_;
}


static void _tab_bar_close_page_document_tab_close_clicked (DocumentTab* _sender, DocumentTab* tab, gpointer self) {
	tab_bar_close_page ((TabBar*) self, tab);
}


static void _tab_bar_switch_page_document_tab_tab_clicked (DocumentTab* _sender, DocumentTab* tab, gpointer self) {
	tab_bar_switch_page ((TabBar*) self, tab);
}


void tab_bar_add_page (TabBar* self, DocumentTab* tab, gboolean new_page) {
	gint _tmp0_ = 0;
	DocumentTab* _tmp13_ = NULL;
	DocumentTab* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (tab != NULL);
	_tmp0_ = self->tab_num;
	if (_tmp0_ < 5) {
		gint _tmp1_ = 0;
		DocumentTab* _tmp3_ = NULL;
		DocumentTab* _tmp4_ = NULL;
		DocumentTab* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		_tmp1_ = self->priv->tab_extra_num;
		if (_tmp1_ == 0) {
			GtkEventBox* _tmp2_ = NULL;
			_tmp2_ = self->priv->extra_menu;
			gtk_widget_hide ((GtkWidget*) _tmp2_);
		}
		_tmp3_ = tab;
		gtk_box_pack_start ((GtkBox*) self, (GtkWidget*) _tmp3_, TRUE, TRUE, (guint) 5);
		_tmp4_ = tab;
		_tmp5_ = _g_object_ref0 (_tmp4_);
		self->priv->_tabs = g_list_append (self->priv->_tabs, _tmp5_);
		_tmp6_ = self->tab_num;
		self->tab_num = _tmp6_ + 1;
	} else {
		GtkEventBox* _tmp7_ = NULL;
		GtkBox* _tmp8_ = NULL;
		DocumentTab* _tmp9_ = NULL;
		DocumentTab* _tmp10_ = NULL;
		DocumentTab* _tmp11_ = NULL;
		gint _tmp12_ = 0;
		_tmp7_ = self->priv->extra_menu;
		gtk_widget_show ((GtkWidget*) _tmp7_);
		_tmp8_ = self->priv->extra_box;
		_tmp9_ = tab;
		gtk_box_pack_start (_tmp8_, (GtkWidget*) _tmp9_, FALSE, TRUE, (guint) 7);
		_tmp10_ = tab;
		_tmp11_ = _g_object_ref0 (_tmp10_);
		self->priv->_extra_tabs = g_list_append (self->priv->_extra_tabs, _tmp11_);
		_tmp12_ = self->priv->tab_extra_num;
		self->priv->tab_extra_num = _tmp12_ + 1;
	}
	_tmp13_ = tab;
	g_signal_connect_object (_tmp13_, "close-clicked", (GCallback) _tab_bar_close_page_document_tab_close_clicked, self, 0);
	_tmp14_ = tab;
	g_signal_connect_object (_tmp14_, "tab-clicked", (GCallback) _tab_bar_switch_page_document_tab_tab_clicked, self, 0);
	_tmp15_ = new_page;
	if (_tmp15_) {
		DocumentTab* _tmp16_ = NULL;
		_tmp16_ = tab;
		tab_bar_switch_page (self, _tmp16_);
	}
}


void tab_bar_switch_page (TabBar* self, DocumentTab* tab) {
	GList* _tmp0_ = NULL;
	DocumentTab* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	DocumentTab* _tmp5_ = NULL;
	GtkScrolledWindow* _tmp6_ = NULL;
	GtkScrolledWindow* _tmp7_ = NULL;
	GtkStack* _tmp9_ = NULL;
	DocumentTab* _tmp10_ = NULL;
	GtkScrolledWindow* _tmp11_ = NULL;
	GtkScrolledWindow* _tmp12_ = NULL;
	DocumentTab* _tmp13_ = NULL;
	DocumentTab* _tmp14_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (tab != NULL);
	_tmp0_ = self->priv->_extra_tabs;
	_tmp1_ = tab;
	_tmp2_ = g_list_index (_tmp0_, _tmp1_);
	if (_tmp2_ != (-1)) {
		GtkPopover* _tmp3_ = NULL;
		_tmp3_ = self->priv->extra_popup;
		gtk_widget_show_all ((GtkWidget*) _tmp3_);
	} else {
		GtkPopover* _tmp4_ = NULL;
		_tmp4_ = self->priv->extra_popup;
		gtk_widget_hide ((GtkWidget*) _tmp4_);
	}
	_tmp5_ = tab;
	_tmp6_ = document_tab_get_tab_widget (_tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp7_ == NULL) {
		FILE* _tmp8_ = NULL;
		_tmp8_ = stdout;
		fprintf (_tmp8_, "PUTO ERROR!\n");
	}
	_tmp9_ = self->priv->stack;
	_tmp10_ = tab;
	_tmp11_ = document_tab_get_tab_widget (_tmp10_);
	_tmp12_ = _tmp11_;
	gtk_stack_set_visible_child (_tmp9_, (GtkWidget*) _tmp12_);
	tab_bar_refresh_marked (self);
	_tmp13_ = tab;
	document_tab_mark_title (_tmp13_);
	_tmp14_ = tab;
	g_signal_emit_by_name (self, "page-switched", _tmp14_);
}


DocumentTab* tab_bar_get_current_page (TabBar* self, GtkWidget* current_doc) {
	DocumentTab* result = NULL;
	DocumentTab* current_tab = NULL;
	GtkWidget* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	current_tab = NULL;
	_tmp0_ = current_doc;
	if (_tmp0_ != NULL) {
		DocumentTab* _tmp16_ = NULL;
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp1_ = FALSE;
				_tmp1_ = TRUE;
				while (TRUE) {
					gint _tmp3_ = 0;
					GList* _tmp4_ = NULL;
					guint _tmp5_ = 0U;
					GList* _tmp6_ = NULL;
					gint _tmp7_ = 0;
					gconstpointer _tmp8_ = NULL;
					GtkScrolledWindow* _tmp9_ = NULL;
					GtkScrolledWindow* _tmp10_ = NULL;
					GtkWidget* _tmp11_ = NULL;
					if (!_tmp1_) {
						gint _tmp2_ = 0;
						_tmp2_ = i;
						i = _tmp2_ + 1;
					}
					_tmp1_ = FALSE;
					_tmp3_ = i;
					_tmp4_ = self->priv->_tabs;
					_tmp5_ = g_list_length (_tmp4_);
					if (!(((guint) _tmp3_) < _tmp5_)) {
						break;
					}
					_tmp6_ = self->priv->_tabs;
					_tmp7_ = i;
					_tmp8_ = g_list_nth_data (_tmp6_, (guint) _tmp7_);
					_tmp9_ = document_tab_get_tab_widget ((DocumentTab*) _tmp8_);
					_tmp10_ = _tmp9_;
					_tmp11_ = current_doc;
					if (G_TYPE_CHECK_INSTANCE_CAST (_tmp10_, gtk_widget_get_type (), GtkWidget) == _tmp11_) {
						GList* _tmp12_ = NULL;
						gint _tmp13_ = 0;
						gconstpointer _tmp14_ = NULL;
						DocumentTab* _tmp15_ = NULL;
						_tmp12_ = self->priv->_tabs;
						_tmp13_ = i;
						_tmp14_ = g_list_nth_data (_tmp12_, (guint) _tmp13_);
						_tmp15_ = _g_object_ref0 ((DocumentTab*) _tmp14_);
						_g_object_unref0 (current_tab);
						current_tab = _tmp15_;
					}
				}
			}
		}
		_tmp16_ = current_tab;
		if (_tmp16_ == NULL) {
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp17_ = FALSE;
					_tmp17_ = TRUE;
					while (TRUE) {
						gint _tmp19_ = 0;
						GList* _tmp20_ = NULL;
						guint _tmp21_ = 0U;
						GList* _tmp22_ = NULL;
						gint _tmp23_ = 0;
						gconstpointer _tmp24_ = NULL;
						GtkScrolledWindow* _tmp25_ = NULL;
						GtkScrolledWindow* _tmp26_ = NULL;
						GtkWidget* _tmp27_ = NULL;
						if (!_tmp17_) {
							gint _tmp18_ = 0;
							_tmp18_ = i;
							i = _tmp18_ + 1;
						}
						_tmp17_ = FALSE;
						_tmp19_ = i;
						_tmp20_ = self->priv->_extra_tabs;
						_tmp21_ = g_list_length (_tmp20_);
						if (!(((guint) _tmp19_) < _tmp21_)) {
							break;
						}
						_tmp22_ = self->priv->_extra_tabs;
						_tmp23_ = i;
						_tmp24_ = g_list_nth_data (_tmp22_, (guint) _tmp23_);
						_tmp25_ = document_tab_get_tab_widget ((DocumentTab*) _tmp24_);
						_tmp26_ = _tmp25_;
						_tmp27_ = current_doc;
						if (G_TYPE_CHECK_INSTANCE_CAST (_tmp26_, gtk_widget_get_type (), GtkWidget) == _tmp27_) {
							GList* _tmp28_ = NULL;
							gint _tmp29_ = 0;
							gconstpointer _tmp30_ = NULL;
							DocumentTab* _tmp31_ = NULL;
							_tmp28_ = self->priv->_extra_tabs;
							_tmp29_ = i;
							_tmp30_ = g_list_nth_data (_tmp28_, (guint) _tmp29_);
							_tmp31_ = _g_object_ref0 ((DocumentTab*) _tmp30_);
							_g_object_unref0 (current_tab);
							current_tab = _tmp31_;
						}
					}
				}
			}
		}
	}
	result = current_tab;
	return result;
}


void tab_bar_switch_page_next (TabBar* self, DocumentTab* current_tab) {
	GList* _tmp0_ = NULL;
	DocumentTab* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (current_tab != NULL);
	_tmp0_ = self->priv->_tabs;
	_tmp1_ = current_tab;
	_tmp2_ = g_list_index (_tmp0_, _tmp1_);
	if (_tmp2_ != (-1)) {
		DocumentTab* _tmp3_ = NULL;
		GList* _tmp4_ = NULL;
		GList* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		_tmp3_ = current_tab;
		_tmp4_ = self->priv->_tabs;
		_tmp5_ = g_list_last (_tmp4_);
		_tmp6_ = _tmp5_->data;
		if (_tmp3_ == ((DocumentTab*) _tmp6_)) {
			gint _tmp7_ = 0;
			_tmp7_ = self->priv->tab_extra_num;
			if (_tmp7_ > 0) {
				GList* _tmp8_ = NULL;
				GList* _tmp9_ = NULL;
				gconstpointer _tmp10_ = NULL;
				_tmp8_ = self->priv->_extra_tabs;
				_tmp9_ = g_list_first (_tmp8_);
				_tmp10_ = _tmp9_->data;
				tab_bar_switch_page (self, (DocumentTab*) _tmp10_);
			} else {
				GList* _tmp11_ = NULL;
				GList* _tmp12_ = NULL;
				gconstpointer _tmp13_ = NULL;
				_tmp11_ = self->priv->_tabs;
				_tmp12_ = g_list_first (_tmp11_);
				_tmp13_ = _tmp12_->data;
				tab_bar_switch_page (self, (DocumentTab*) _tmp13_);
			}
		} else {
			DocumentTab* tab = NULL;
			GList* _tmp14_ = NULL;
			GList* _tmp15_ = NULL;
			DocumentTab* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gconstpointer _tmp18_ = NULL;
			DocumentTab* _tmp19_ = NULL;
			DocumentTab* _tmp20_ = NULL;
			_tmp14_ = self->priv->_tabs;
			_tmp15_ = self->priv->_tabs;
			_tmp16_ = current_tab;
			_tmp17_ = g_list_index (_tmp15_, _tmp16_);
			_tmp18_ = g_list_nth_data (_tmp14_, (guint) (_tmp17_ + 1));
			_tmp19_ = _g_object_ref0 ((DocumentTab*) _tmp18_);
			tab = _tmp19_;
			_tmp20_ = tab;
			tab_bar_switch_page (self, _tmp20_);
			_g_object_unref0 (tab);
		}
	} else {
		GList* _tmp21_ = NULL;
		DocumentTab* _tmp22_ = NULL;
		gint _tmp23_ = 0;
		_tmp21_ = self->priv->_extra_tabs;
		_tmp22_ = current_tab;
		_tmp23_ = g_list_index (_tmp21_, _tmp22_);
		if (_tmp23_ != (-1)) {
			DocumentTab* _tmp24_ = NULL;
			GList* _tmp25_ = NULL;
			GList* _tmp26_ = NULL;
			gconstpointer _tmp27_ = NULL;
			_tmp24_ = current_tab;
			_tmp25_ = self->priv->_extra_tabs;
			_tmp26_ = g_list_last (_tmp25_);
			_tmp27_ = _tmp26_->data;
			if (_tmp24_ == ((DocumentTab*) _tmp27_)) {
				GList* _tmp28_ = NULL;
				GList* _tmp29_ = NULL;
				gconstpointer _tmp30_ = NULL;
				_tmp28_ = self->priv->_tabs;
				_tmp29_ = g_list_first (_tmp28_);
				_tmp30_ = _tmp29_->data;
				tab_bar_switch_page (self, (DocumentTab*) _tmp30_);
			} else {
				DocumentTab* tab = NULL;
				GList* _tmp31_ = NULL;
				GList* _tmp32_ = NULL;
				DocumentTab* _tmp33_ = NULL;
				gint _tmp34_ = 0;
				gconstpointer _tmp35_ = NULL;
				DocumentTab* _tmp36_ = NULL;
				DocumentTab* _tmp37_ = NULL;
				_tmp31_ = self->priv->_extra_tabs;
				_tmp32_ = self->priv->_extra_tabs;
				_tmp33_ = current_tab;
				_tmp34_ = g_list_index (_tmp32_, _tmp33_);
				_tmp35_ = g_list_nth_data (_tmp31_, (guint) (_tmp34_ + 1));
				_tmp36_ = _g_object_ref0 ((DocumentTab*) _tmp35_);
				tab = _tmp36_;
				_tmp37_ = tab;
				tab_bar_switch_page (self, _tmp37_);
				_g_object_unref0 (tab);
			}
		}
	}
}


void tab_bar_switch_page_prev (TabBar* self, DocumentTab* current_tab) {
	GList* _tmp0_ = NULL;
	DocumentTab* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (current_tab != NULL);
	_tmp0_ = self->priv->_tabs;
	_tmp1_ = current_tab;
	_tmp2_ = g_list_index (_tmp0_, _tmp1_);
	if (_tmp2_ != (-1)) {
		DocumentTab* _tmp3_ = NULL;
		GList* _tmp4_ = NULL;
		GList* _tmp5_ = NULL;
		gconstpointer _tmp6_ = NULL;
		_tmp3_ = current_tab;
		_tmp4_ = self->priv->_tabs;
		_tmp5_ = g_list_first (_tmp4_);
		_tmp6_ = _tmp5_->data;
		if (_tmp3_ == ((DocumentTab*) _tmp6_)) {
			gint _tmp7_ = 0;
			_tmp7_ = self->priv->tab_extra_num;
			if (_tmp7_ > 0) {
				GList* _tmp8_ = NULL;
				GList* _tmp9_ = NULL;
				gconstpointer _tmp10_ = NULL;
				_tmp8_ = self->priv->_extra_tabs;
				_tmp9_ = g_list_last (_tmp8_);
				_tmp10_ = _tmp9_->data;
				tab_bar_switch_page (self, (DocumentTab*) _tmp10_);
			} else {
				GList* _tmp11_ = NULL;
				GList* _tmp12_ = NULL;
				gconstpointer _tmp13_ = NULL;
				_tmp11_ = self->priv->_tabs;
				_tmp12_ = g_list_last (_tmp11_);
				_tmp13_ = _tmp12_->data;
				tab_bar_switch_page (self, (DocumentTab*) _tmp13_);
			}
		} else {
			DocumentTab* tab = NULL;
			GList* _tmp14_ = NULL;
			GList* _tmp15_ = NULL;
			DocumentTab* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gconstpointer _tmp18_ = NULL;
			DocumentTab* _tmp19_ = NULL;
			DocumentTab* _tmp20_ = NULL;
			_tmp14_ = self->priv->_tabs;
			_tmp15_ = self->priv->_tabs;
			_tmp16_ = current_tab;
			_tmp17_ = g_list_index (_tmp15_, _tmp16_);
			_tmp18_ = g_list_nth_data (_tmp14_, (guint) (_tmp17_ - 1));
			_tmp19_ = _g_object_ref0 ((DocumentTab*) _tmp18_);
			tab = _tmp19_;
			_tmp20_ = tab;
			tab_bar_switch_page (self, _tmp20_);
			_g_object_unref0 (tab);
		}
	} else {
		GList* _tmp21_ = NULL;
		DocumentTab* _tmp22_ = NULL;
		gint _tmp23_ = 0;
		_tmp21_ = self->priv->_extra_tabs;
		_tmp22_ = current_tab;
		_tmp23_ = g_list_index (_tmp21_, _tmp22_);
		if (_tmp23_ != (-1)) {
			DocumentTab* _tmp24_ = NULL;
			GList* _tmp25_ = NULL;
			GList* _tmp26_ = NULL;
			gconstpointer _tmp27_ = NULL;
			_tmp24_ = current_tab;
			_tmp25_ = self->priv->_extra_tabs;
			_tmp26_ = g_list_first (_tmp25_);
			_tmp27_ = _tmp26_->data;
			if (_tmp24_ == ((DocumentTab*) _tmp27_)) {
				GList* _tmp28_ = NULL;
				GList* _tmp29_ = NULL;
				gconstpointer _tmp30_ = NULL;
				_tmp28_ = self->priv->_tabs;
				_tmp29_ = g_list_last (_tmp28_);
				_tmp30_ = _tmp29_->data;
				tab_bar_switch_page (self, (DocumentTab*) _tmp30_);
			} else {
				DocumentTab* tab = NULL;
				GList* _tmp31_ = NULL;
				GList* _tmp32_ = NULL;
				DocumentTab* _tmp33_ = NULL;
				gint _tmp34_ = 0;
				gconstpointer _tmp35_ = NULL;
				DocumentTab* _tmp36_ = NULL;
				DocumentTab* _tmp37_ = NULL;
				_tmp31_ = self->priv->_extra_tabs;
				_tmp32_ = self->priv->_extra_tabs;
				_tmp33_ = current_tab;
				_tmp34_ = g_list_index (_tmp32_, _tmp33_);
				_tmp35_ = g_list_nth_data (_tmp31_, (guint) (_tmp34_ - 1));
				_tmp36_ = _g_object_ref0 ((DocumentTab*) _tmp35_);
				tab = _tmp36_;
				_tmp37_ = tab;
				tab_bar_switch_page (self, _tmp37_);
				_g_object_unref0 (tab);
			}
		}
	}
}


void tab_bar_close_page (TabBar* self, DocumentTab* tab) {
	gint page_num = 0;
	DocumentTab* _tmp0_ = NULL;
	gboolean _tmp23_ = FALSE;
	gint _tmp24_ = 0;
	DocumentTab* _tmp27_ = NULL;
	gint _tmp28_ = 0;
	g_return_if_fail (self != NULL);
	page_num = -1;
	_tmp0_ = tab;
	if (_tmp0_ != NULL) {
		DocumentTab* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		GList* _tmp3_ = NULL;
		DocumentTab* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		_tmp1_ = tab;
		_tmp2_ = tab_bar_get_page_num (self, _tmp1_);
		page_num = _tmp2_;
		_tmp3_ = self->priv->_tabs;
		_tmp4_ = tab;
		_tmp5_ = g_list_index (_tmp3_, _tmp4_);
		if (_tmp5_ != (-1)) {
			DocumentTab* _tmp6_ = NULL;
			gint _tmp7_ = 0;
			gint _tmp8_ = 0;
			_tmp6_ = tab;
			self->priv->_tabs = g_list_remove (self->priv->_tabs, _tmp6_);
			_tmp7_ = self->tab_num;
			self->tab_num = _tmp7_ - 1;
			_tmp8_ = self->priv->tab_extra_num;
			if (_tmp8_ > 0) {
				DocumentTab* aux_tab = NULL;
				GList* _tmp9_ = NULL;
				GList* _tmp10_ = NULL;
				gconstpointer _tmp11_ = NULL;
				DocumentTab* _tmp12_ = NULL;
				GtkBox* _tmp13_ = NULL;
				DocumentTab* _tmp14_ = NULL;
				DocumentTab* _tmp15_ = NULL;
				DocumentTab* _tmp16_ = NULL;
				gint _tmp17_ = 0;
				_tmp9_ = self->priv->_extra_tabs;
				_tmp10_ = g_list_first (_tmp9_);
				_tmp11_ = _tmp10_->data;
				_tmp12_ = _g_object_ref0 ((DocumentTab*) _tmp11_);
				aux_tab = _tmp12_;
				_tmp13_ = self->priv->extra_box;
				_tmp14_ = aux_tab;
				gtk_container_remove ((GtkContainer*) _tmp13_, (GtkWidget*) _tmp14_);
				_tmp15_ = aux_tab;
				tab_bar_add_page (self, _tmp15_, FALSE);
				_tmp16_ = aux_tab;
				self->priv->_extra_tabs = g_list_remove (self->priv->_extra_tabs, _tmp16_);
				_tmp17_ = self->priv->tab_extra_num;
				self->priv->tab_extra_num = _tmp17_ - 1;
				_g_object_unref0 (aux_tab);
			}
		} else {
			GList* _tmp18_ = NULL;
			DocumentTab* _tmp19_ = NULL;
			gint _tmp20_ = 0;
			_tmp18_ = self->priv->_extra_tabs;
			_tmp19_ = tab;
			_tmp20_ = g_list_index (_tmp18_, _tmp19_);
			if (_tmp20_ != (-1)) {
				DocumentTab* _tmp21_ = NULL;
				gint _tmp22_ = 0;
				_tmp21_ = tab;
				self->priv->_extra_tabs = g_list_remove (self->priv->_extra_tabs, _tmp21_);
				_tmp22_ = self->priv->tab_extra_num;
				self->priv->tab_extra_num = _tmp22_ - 1;
			}
		}
	}
	_tmp24_ = self->priv->tab_extra_num;
	if (_tmp24_ == 0) {
		gint _tmp25_ = 0;
		_tmp25_ = self->tab_num;
		_tmp23_ = _tmp25_ <= 5;
	} else {
		_tmp23_ = FALSE;
	}
	if (_tmp23_) {
		GtkEventBox* _tmp26_ = NULL;
		_tmp26_ = self->priv->extra_menu;
		gtk_widget_hide ((GtkWidget*) _tmp26_);
	}
	_tmp27_ = tab;
	_tmp28_ = page_num;
	g_signal_emit_by_name (self, "page-closed", _tmp27_, _tmp28_);
}


static void __lambda5_ (TabBar* self, DocumentTab* entry) {
	DocumentTab* _tmp0_ = NULL;
	g_return_if_fail (entry != NULL);
	_tmp0_ = entry;
	document_tab_refresh_title (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, TYPE_DOCUMENT_TAB) ? ((DocumentTab*) _tmp0_) : NULL);
}


static void ___lambda5__gfunc (gconstpointer data, gpointer self) {
	__lambda5_ ((TabBar*) self, (DocumentTab*) data);
}


static void __lambda6_ (TabBar* self, DocumentTab* entry) {
	DocumentTab* _tmp0_ = NULL;
	g_return_if_fail (entry != NULL);
	_tmp0_ = entry;
	document_tab_refresh_title (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, TYPE_DOCUMENT_TAB) ? ((DocumentTab*) _tmp0_) : NULL);
}


static void ___lambda6__gfunc (gconstpointer data, gpointer self) {
	__lambda6_ ((TabBar*) self, (DocumentTab*) data);
}


static void tab_bar_refresh_marked (TabBar* self) {
	GList* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_tabs;
	g_list_foreach (_tmp0_, ___lambda5__gfunc, self);
	_tmp1_ = self->priv->_extra_tabs;
	g_list_foreach (_tmp1_, ___lambda6__gfunc, self);
}


gint tab_bar_get_page_num (TabBar* self, DocumentTab* tab) {
	gint result = 0;
	GList* _tmp0_ = NULL;
	DocumentTab* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	GList* _tmp8_ = NULL;
	DocumentTab* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (tab != NULL, 0);
	_tmp0_ = self->priv->_extra_tabs;
	_tmp1_ = tab;
	_tmp2_ = g_list_index (_tmp0_, _tmp1_);
	if (_tmp2_ != (-1)) {
		GList* _tmp3_ = NULL;
		DocumentTab* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		GList* _tmp6_ = NULL;
		guint _tmp7_ = 0U;
		_tmp3_ = self->priv->_extra_tabs;
		_tmp4_ = tab;
		_tmp5_ = g_list_index (_tmp3_, _tmp4_);
		_tmp6_ = self->priv->_tabs;
		_tmp7_ = g_list_length (_tmp6_);
		result = _tmp5_ + ((gint) _tmp7_);
		return result;
	}
	_tmp8_ = self->priv->_tabs;
	_tmp9_ = tab;
	_tmp10_ = g_list_index (_tmp8_, _tmp9_);
	result = _tmp10_;
	return result;
}


GList* tab_bar_get_extra_tabs (TabBar* self) {
	GList* result;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_extra_tabs;
	result = _tmp0_;
	return result;
}


GList* tab_bar_get_tabs (TabBar* self) {
	GList* result;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_tabs;
	result = _tmp0_;
	return result;
}


static void g_cclosure_user_marshal_VOID__OBJECT_INT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_INT) (gpointer data1, gpointer arg_1, gint arg_2, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_INT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_INT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_int (param_values + 2), data2);
}


static void tab_bar_class_init (TabBarClass * klass) {
	tab_bar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TabBarPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_tab_bar_get_property;
	G_OBJECT_CLASS (klass)->finalize = tab_bar_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), TAB_BAR_EXTRA_TABS, g_param_spec_pointer ("extra-tabs", "extra-tabs", "extra-tabs", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), TAB_BAR_TABS, g_param_spec_pointer ("tabs", "tabs", "tabs", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("page_closed", TYPE_TAB_BAR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_INT, G_TYPE_NONE, 2, TYPE_DOCUMENT_TAB, G_TYPE_INT);
	g_signal_new ("page_switched", TYPE_TAB_BAR, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, TYPE_DOCUMENT_TAB);
}


static void tab_bar_instance_init (TabBar * self) {
	self->priv = TAB_BAR_GET_PRIVATE (self);
	self->priv->tab_extra_num = 0;
	self->tab_num = 0;
}


static void tab_bar_finalize (GObject* obj) {
	TabBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TAB_BAR, TabBar);
	_g_object_unref0 (self->priv->stack);
	_g_object_unref0 (self->priv->extra_box);
	_g_object_unref0 (self->priv->extra_menu);
	_g_object_unref0 (self->priv->extra_popup);
	__g_list_free__g_object_unref0_0 (self->priv->_extra_tabs);
	__g_list_free__g_object_unref0_0 (self->priv->_tabs);
	G_OBJECT_CLASS (tab_bar_parent_class)->finalize (obj);
}


GType tab_bar_get_type (void) {
	static volatile gsize tab_bar_type_id__volatile = 0;
	if (g_once_init_enter (&tab_bar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TabBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) tab_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TabBar), 0, (GInstanceInitFunc) tab_bar_instance_init, NULL };
		GType tab_bar_type_id;
		tab_bar_type_id = g_type_register_static (gtk_box_get_type (), "TabBar", &g_define_type_info, 0);
		g_once_init_leave (&tab_bar_type_id__volatile, tab_bar_type_id);
	}
	return tab_bar_type_id__volatile;
}


static void _vala_tab_bar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	TabBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_TAB_BAR, TabBar);
	switch (property_id) {
		case TAB_BAR_EXTRA_TABS:
		g_value_set_pointer (value, tab_bar_get_extra_tabs (self));
		break;
		case TAB_BAR_TABS:
		g_value_set_pointer (value, tab_bar_get_tabs (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



